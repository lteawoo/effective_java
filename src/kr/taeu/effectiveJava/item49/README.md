# 매개변수가 유효한지 검사하라
메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다.(인덱스 값은 음수이면 안된다 등..) 이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다. 이는 "오류는 가능한 빨리(발생한 곳에서) 잡아야 한다."는 일반 원칙의 사례다. 오류를 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 발생지점을 찾기 어려워진다.

메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다.
## 매개변수 검사를 제대로 하지 못한다면?
1. 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
2. 메서드가 잘 수행되지만 잘못된 결과를 반환할 수 있다.
3. 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알수 없는 시점에 이 메서드와 관련 없는 오류를 낼때다.

다시 말해 매개변수 검사에 실패하면 실패 원자성(failur atomicity)을 어기는 결과를 낳는다.

public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.(@throws 자바독 태그를 사용하면 된다.) 보통은 IllegalArgumentException, IndexOutOfBoundsException, NullPointerException 중 하나가 될 것이다. 매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야한다. 다음은 이 전형적인 예다.
```java
/**
 * (현재 값 mod m) 값을 반환한다. 이 메서드는
 * 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.
 *
 * @param m 계수(양수여야 한다.)
 * @return 현재 값 mod m
 * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
 */
public BigInteger mod(BigInteger m) {
  if (m.signum() <= 0)
    throw new ArithmeticException("계수(m)는 양수여야 합니다. " + m);
    ...// 계산수행
}
```
이 메서드는 m이 null이면 m.signum() 호출 때 NullPointerException을 던진다. 그런데 "m이 null일 때 NullPointerException을 던진다"라는 말은 메서드 설명 어디에도 없다. 그 이유는 이 설명을 BigInteger 클래스 수준에서 기술했기 때문이다. 클래스 수준 주석은 그 클래싀의 모든 public 메서드에 적용되므로 각 메서드에 일일이 기술하는 것보다 훨씬 깔끔한 방법이다. @Nullable이나 이와 비슷한 애너테이션을 사용해 특정 매개변수는 null이 될수 있다고 알려줄 수도 있지만. 표준적인 방법은 아니다.

자바 7에 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기도 편하니, 더 이상 null검사를 수동으로 하지 않아도 된다.
```java
// 자바의 null 검사 기능 사용하기
this.strategy = Objects.requireNonNull(strategy, "전략");
```
반환값은 무시하고 필요한 곳 어디서든 순수한 null 검사 목적으로 사용해도 된다.

자바 9에서는 Objects에 범위 검사 기능도 더해졌다. checkFromIndexSize, checkFromToIndex, checkIndex라는 메서드들인데, null 검사 메서드만큼 유연하지는 않다. 예외 메시지를 지정할수 없고, 리스트와 배열전용으로 설계됐다, 또한 닫힌 범위(closed range; 양 끝단 값을 포함하는)는 다루지 못한다. 그래도 이런 제약이 걸림돌이 되지 않는 상황에서는 아주 유용하다.

공개되지 않은 메서드라면 패키지 제작자인 여러분이 메서드가 호출되는 상황을 통제할 수있다. 따라서 유효한 값만이 메서드에 넘겨지라는 것을 여러분이 보증할 수 있고 그렇게 해야한다. public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증 할 수있다.
```java
// 재귀 정렬용 private 도우미 함수
private static void sort(long a[], int offset, int length) {
  aasert a != null;
  assert offset >= 0 && offset <= a.length;
  assert length >= 0 && length <= a.length - offset;
  ...//계산
}
```
여기서의 핵심은 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다는 것이다. 단언문은 몇가지 면에서 일반적인 유효성 검사와 다르다
1. 실패하면 AssertionError를 던진다.
2. 런타임에 아무런 효과도, 성능저하도 없다.(단 java를 실행할때 명령줄에서 -ea 또는 --enableassertions 플래그 설정하면 런타임에 영향을 준다.)

메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경 써서 검사해야 한다. 정적 팩터리 메서드를 생각해보라. 입력받은 int 배열의 List 뷰(view)를 반환하는 메서드였다. 이 메서드는 Objects.requireNonNull을 이용해 Null 검사르 수행하므로 클라이언트가 null을 건네면 npe를 던진다.

만약 이 검사를 생략했다면 새로 생성한 List 인스턴스를 반환하는데, 클라이언트가 돌려받은 List를 사용하려 할때 비로소 npe가 발생한다. 이때가 되면 list를 어디서 가져왔는지 추적하기 어려워 디버깅이 힘들다.

생성자는 "나중에 쓰려고 저장하는 매개변수의 유효성을 검사하라"는 원칙의 특수한 사례다. 생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는데 꼭 필요하다.

메서드 몸체 실행전 매개변수 유효성 검사를 해야한다는 규칙에도 예외가 있다. 유효성 검사 비용이 지나치게 높거나 실용적이지 않을때, 계산과정에서 암묵적인 검사가 수행될 때다.

Collections.sort(List) 처럼 객체 리스트를 정렬하는 메서드를 생각해 보자, 리스트 안의 객체들은 모두 상호 비교될 수 있어야 하며, 정렬 과정에서 이 비교가 이루어진다. 만약 상호 비교될 수 없는 타입의 객체가 들어 있다면 그 객체와 비교 할때 ClassCastException을 던질 것이다. 앞서 리스트 안의 모든 객체가 상호 비교될수 있는지 검사해봐야 별다른 실익이 없다. 하지만 암묵적 유효성 검사에 너무 의존했다가는 실패 원자성을 해칠수 있으니 조심하자.

때로는 계산과정에서 필요한 유효성 검사가 이뤄지지만 실패했을 때 잘못된 예외를 던지기도 한다. 달리 말하면, 계산 중 잘못된 매개변수 값을 사용해 발생한 예외와 API 문서에서 던지기로한 예외가 다를 수 있다는 뜻이다. 이런 경우에는 아이템 73에서 설명한느 예외 번역 관용구를 사용하여 API 문서에 기재된 예외로 번역해줘야 한다.

이번 아이템을 "매개변수에 제약을 두는 게 좋다"고 해석해서는 안된다 메서드는 최대한 범용적으로 설계해야 한다. 메서드가 건네받은 매개변수로 무언가 제대로 된 일을 할수있다면 매개변수 제약은 최소로 하는게 좋다.